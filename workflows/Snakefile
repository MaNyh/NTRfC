from snakemake.utils import validate
import os

def write_dummy_output(output):
    with open(output,"w") as fhandle:
        fhandle.write("dummystuff")

rule all:
    input:
        "postprocessedsolution.txt"

# todo: we need to use a configuration-file to decide, which rule should be called.
#  https://json-schema.org/understanding-json-schema/reference/conditionals.html#if-then-else
#  either way, we need to validate the user input. as the validation needs to be dynamic, you should use the link above
#  to write the validation.schema.yml

# the yaml/schema may look like this:
"""
meshing:
    profile:
        algorithm: string: pointcloud | nacagen | parsec
         %if algorithm = nacagen | parsec
         stagger_angle: float
         chordlemgth: float
         ...

        alpha: float # this parameter might also be computed iteratively by a alphashape-library or by  an optimization-method
"""

# todo: only use the validation.yml and the validation.schema.yml after calling snakemake as a module.
#  it does not make sense to work on the validation before using the ntrfc.workflows as a module

rule meshing:
    output:
        "mesh.txt"
    run:
        write_dummy_output(output[0])

rule casecreation:
    input:
        "mesh.txt"
    output:
        "case.txt"
    run:
        write_dummy_output(output[0])

rule run:
    input:
        "case.txt"
    output:
        "solution.txt"
    run:
        write_dummy_output(output[0])

rule post:
    input:
        "solution.txt"
    output:
        "postprocessedsolution.txt"
    run:
        write_dummy_output(output[0])
